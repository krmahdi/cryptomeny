'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

class Position {
  constructor(line, col, index) {
    this.line = void 0;
    this.column = void 0;
    this.index = void 0;
    this.line = line;
    this.column = col;
    this.index = index;
  }

}
class SourceLocation {
  constructor(start, end) {
    this.start = void 0;
    this.end = void 0;
    this.filename = void 0;
    this.identifierName = void 0;
    this.start = start;
    this.end = end;
  }

}
function createPositionWithColumnOffset(position, columnOffset) {
  const {
    line,
    column,
    index
  } = position;
  return new Position(line, column + columnOffset, index + columnOffset);
}

const ParseErrorCodes = Object.freeze({
  SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
  SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
});

const reflect = (keys, last = keys.length - 1) => ({
  get() {
    return keys.reduce((object, key) => object[key], this);
  },

  set(value) {
    keys.reduce((item, key, i) => i === last ? item[key] = value : item[key], this);
  }

});

const instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map(key => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === "function" ? {
  value: descriptor,
  enumerable: false
} : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
  configurable: true
}, descriptor)), Object.assign(new constructor(), properties));

var ModuleErrors = (_ => ({
  ImportMetaOutsideModule: _(`import.meta may appear only with 'sourceType: "module"'`, {
    code: ParseErrorCodes.SourceTypeModuleError
  }),
  ImportOutsideModule: _(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
    code: ParseErrorCodes.SourceTypeModuleError
  })
}));

const NodeDescriptions = {
  ArrayPattern: "array destructuring pattern",
  AssignmentExpression: "assignment expression",
  AssignmentPattern: "assignment expression",
  ArrowFunctionExpression: "arrow function expression",
  ConditionalExpression: "conditional expression",
  ForOfStatement: "for-of statement",
  ForInStatement: "for-in statement",
  ForStatement: "for-loop",
  FormalParameters: "function parameter list",
  Identifier: "identifier",
  ObjectPattern: "object destructuring pattern",
  ParenthesizedExpression: "parenthesized expression",
  RestElement: "rest element",
  UpdateExpression: {
    true: "prefix operation",
    false: "postfix operation"
  },
  VariableDeclarator: "variable declaration",
  YieldExpression: "yield expression"
};

const toNodeDescription = ({
  type,
  prefix
}) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];

var StandardErrors = (_ => ({
  AccessorIsGenerator: _(({
    kind
  }) => `A ${kind}ter cannot be a generator.`),
  ArgumentsInClass: _("'arguments' is only allowed in functions and class methods."),
  AsyncFunctionInSingleStatementContext: _("Async functions can only be declared at the top level or inside a block."),
  AwaitBindingIdentifier: _("Can not use 'await' as identifier inside an async function."),
  AwaitBindingIdentifierInStaticBlock: _("Can not use 'await' as identifier inside a static block."),
  AwaitExpressionFormalParameter: _("'await' is not allowed in async function parameters."),
  AwaitNotInAsyncContext: _("'await' is only allowed within async functions and at the top levels of modules."),
  AwaitNotInAsyncFunction: _("'await' is only allowed within async functions."),
  BadGetterArity: _("A 'get' accesor must not have any formal parameters."),
  BadSetterArity: _("A 'set' accesor must have exactly one formal parameter."),
  BadSetterRestParameter: _("A 'set' accesor function argument must not be a rest parameter."),
  ConstructorClassField: _("Classes may not have a field named 'constructor'."),
  ConstructorClassPrivateField: _("Classes may not have a private field named '#constructor'."),
  ConstructorIsAccessor: _("Class constructor may not be an accessor."),
  ConstructorIsAsync: _("Constructor can't be an async function."),
  ConstructorIsGenerator: _("Constructor can't be a generator."),
  DeclarationMissingInitializer: _(({
    kind
  }) => `Missing initializer in ${kind} declaration.`),
  DecoratorBeforeExport: _("Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."),
  DecoratorConstructor: _("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
  DecoratorExportClass: _("Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."),
  DecoratorSemicolon: _("Decorators must not be followed by a semicolon."),
  DecoratorStaticBlock: _("Decorators can't be used with a static block."),
  DeletePrivateField: _("Deleting a private field is not allowed."),
  DestructureNamedImport: _("ES2015 named imports do not destructure. Use another statement for destructuring after the import."),
  DuplicateConstructor: _("Duplicate constructor in the same class."),
  DuplicateDefaultExport: _("Only one default export allowed per module."),
  DuplicateExport: _(({
    exportName
  }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`),
  DuplicateProto: _("Redefinition of __proto__ property."),
  DuplicateRegExpFlags: _("Duplicate regular expression flag."),
  ElementAfterRest: _("Rest element must be last element."),
  EscapedCharNotAnIdentifier: _("Invalid Unicode escape."),
  ExportBindingIsString: _(({
    localName,
    exportName
  }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`),
  ExportDefaultFromAsIdentifier: _("'from' is not allowed as an identifier after 'export default'."),
  ForInOfLoopInitializer: _(({
    type
  }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`),
  ForOfAsync: _("The left-hand side of a for-of loop may not be 'async'."),
  ForOfLet: _("The left-hand side of a for-of loop may not start with 'let'."),
  GeneratorInSingleStatementContext: _("Generators can only be declared at the top level or inside a block."),
  IllegalBreakContinue: _(({
    type
  }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`),
  IllegalLanguageModeDirective: _("Illegal 'use strict' directive in function with non-simple parameter list."),
  IllegalReturn: _("'return' outside of function."),
  ImportBindingIsString: _(({
    importName
  }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`),
  ImportCallArgumentTrailingComma: _("Trailing comma is disallowed inside import(...) arguments."),
  ImportCallArity: _(({
    maxArgumentCount
  }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`),
  ImportCallNotNewExpression: _("Cannot use new with import(...)."),
  ImportCallSpreadArgument: _("`...` is not allowed in `import()`